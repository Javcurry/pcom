package templates

// LucasTemplate is template for .lucas.go files
var LucasTemplate = `// Code generated by lucas. DO NOT EDIT.
// Source: {{.Path}}

package {{.GoPKGName}}

import (
   "context"
{{- range $index, $pkg := .LucasImportPKGs}}
   {{$pkg.Alias}} "{{$pkg.PKGName}}"
{{- end}}
)

type {{.ServiceName}}Native interface {
{{- range $funcIndex, $func := .Functions}}
    {{- if $func.AggregateRequest}}
    {{$func.FuncName}}({{- if $func.WithCtx}}ctx context.Context, {{end}}
        {{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
            {{- if ne $fieldIndex 0}},{{" "}}
            {{- end}}arg{{$fieldIndex}}{{" "}} 
            {{- if $arg.IsPtr}}*
            {{- else if $arg.IsRepeated}}[]{{if $arg.IsPtrInRepeated}}*{{end}}
            {{- else if $arg.IsMap}}map[{{$arg.KeyTypeNameWithGoPkg}}]
            {{- end}}{{$arg.TypeNameWithGoPkg}}
        {{- end}}) ({{template "response" $func}}error)
    {{- else}}
    {{$func.FuncName}}({{- if $func.WithCtx}}ctx context.Context, {{end}}in *{{$func.RequestDefinition.TypeNameWithGoPkg}}) (
        {{- if $func.AggregateResponse}}
            {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}{{$rArg.TypeNameWithGoPkg}}, {{end}}
        {{- else}}*{{$func.ResponseDefinition.TypeNameWithGoPkg}},{{" "}} 
        {{- end}}error)
    {{- end}}
{{- end}}
}

// client 

type {{.ServiceNameLowerCase}}NativeClient struct {
     service {{.ServiceName}}
}

// New{{.ServiceName}} return GRPC style server implement
func New{{.ServiceName}}NativeClient(service {{.ServiceName}}) *{{.ServiceNameLowerCase}}NativeClient {
    return &{{.ServiceNameLowerCase}}NativeClient{
        service: service,
    }
}
{{range $funcIndex, $func := .Functions}}
{{- if $func.AggregateRequest}}
func (server *{{$.ServiceNameLowerCase}}NativeClient) {{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx context.Context, {{end}}
        {{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
            {{- if ne $fieldIndex 0}}, {{end}}arg{{$fieldIndex}}{{" "}}
            {{- if $arg.IsPtr}}*
            {{- else if $arg.IsRepeated}}[]{{if $arg.IsPtrInRepeated}}*{{end}}
            {{- else if $arg.IsMap}}map[{{$arg.KeyTypeNameWithGoPkg}}]
            {{- end}}{{$arg.TypeNameWithGoPkg}}
        {{- end}}) ({{- template "response" $func}}error) {
    in := &{{$func.RequestDefinition.TypeNameWithGoPkg}} {
    {{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
        {{if or $arg.IsStruct $arg.IsStructInPtr}}{{$arg.TypeName}}{{else}}{{$arg.FieldNameGenFromProtobuf}}{{end}}:{{" "}}
        {{- if $arg.IsStructInPtr -}}*
        {{- else if $arg.NeedCastInLucas}}convClient{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}}(
        {{- end}}arg{{$fieldIndex}}{{if $arg.NeedCastInLucas}}){{end}},
    {{- end}}
    }
{{- else}}
func (server *{{$.ServiceNameLowerCase}}NativeClient) {{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx context.Context,{{" "}}
    {{- end}}in *{{$func.RequestDefinition.TypeNameWithGoPkg}}) ({{- template "response" $func}}error) {
{{- end}}
{{- if $func.AggregateResponse}}
    {{$length := len $func.AggregatedResponseDefinition.Args}}
    {{- if eq $length 0}}_, {{else}}response, {{end}}err := server.service.{{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx, {{end}}in)
    return{{" "}} 
    {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}
        {{- if $rArg.IsPtr}}&{{end}}
        {{- if $rArg.NeedCastInLucas}}convClient{{$func.FuncName}}Output{{$rArg.FieldNameGenFromProtobuf}}(
        {{- end}}response.{{$rArg.FieldNameGenFromProtobuf}}
        {{- if $rArg.NeedCastInLucas}}){{end}},{{" "}} 
    {{- end}}err
{{- else}}
    return server.service.{{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx, {{end}}in)
{{- end}}
}
{{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
    {{- if $arg.NeedCastInLucas}}
        {{- if $arg.IsMap}}

func convClient{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}} (in map[{{$arg.KeyTypeNameWithGoPkg}}]{{$arg.TypeNameWithGoPkg}}) map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}} {
    out := make(map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}})
    for k, v := range in {
        out[
        {{- if $arg.KeyNeedCast}}{{$arg.KeyTypeGenFromProtobuf}}(
        {{- end}}k
        {{- if $arg.KeyNeedCast}})
        {{- end}}] = {{if $arg.NeedCast}}{{$arg.TypeGenFromProtobuf}}({{end}}v
        {{- if $arg.NeedCast}}){{end}}
    }
    return out
}
        {{- else if $arg.IsRepeated}}

func convClient{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}} (in []{{$arg.TypeNameWithGoPkg}}) []{{$arg.TypeGenFromProtobuf}} {
    out := make([]{{$arg.TypeGenFromProtobuf}}, len(in))
    for i := 0; i < len(in); i++ {
        out[i] = {{$arg.TypeGenFromProtobuf}}(in[i])
    }
    return out
}
        {{- else}}

func convClient{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}} (in {{$arg.TypeNameWithGoPkg}}) {{$arg.TypeGenFromProtobuf}} {
    return {{$arg.TypeGenFromProtobuf}}(in)
}
        {{- end}}
    {{- end}}
{{- end}}
{{- range $fieldIndex, $arg := $func.AggregatedResponseDefinition.Args}}
    {{- if $arg.NeedCastInLucas}}
        {{- if $arg.IsMap}}

func convClient{{$func.FuncName}}Output{{$arg.FieldNameGenFromProtobuf}} (in map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}}) map[{{$arg.KeyTypeNameWithGoPkg}}]{{$arg.TypeNameWithGoPkg}} {
    out := make(map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}})
    for k, v := range in {
        out[
        {{- if $arg.KeyNeedCast}}{{$arg.KeyTypeNameWithGoPkg}}(
        {{- end}}k
        {{- if $arg.KeyNeedCast}})
        {{- end}}] = {{if $arg.NeedCast}}{{$arg.TypeNameWithGoPkg}}({{end}}v
                    {{- if $arg.NeedCast}}){{end}}
    }
    return out
}
        {{- else if $arg.IsRepeated}}

func convClient{{$func.FuncName}}Output{{$arg.FieldNameGenFromProtobuf}} (in []{{$arg.TypeGenFromProtobuf}}) []{{$arg.TypeNameWithGoPkg}} {
    out := make([]{{$arg.TypeNameWithGoPkg}}, len(in))
    for i := 0; i < len(in); i++ {
        out[i] = {{$arg.TypeNameWithGoPkg}}(in[i])
    }
    return out
}        
        {{- else}}

func convClient{{$func.FuncName}}Output{{$arg.FieldNameGenFromProtobuf}} (in {{$arg.TypeGenFromProtobuf}}) {{$arg.TypeNameWithGoPkg}} {
    return {{$arg.TypeNameWithGoPkg}}(in)
}
        {{- end}}
    {{- end}}
{{- end}}
{{end}}
// server

type {{.ServiceNameLowerCase}}MicroServer struct {
     service *{{.ServiceNameLowerCase}}NativeServer
}

// New{{.ServiceName}}MicroServer returns go-micro style server implement.
func New{{.ServiceName}}MicroServer(service {{.ServiceName}}Native, opts... Option) *{{.ServiceNameLowerCase}}MicroServer {
    server := &{{.ServiceNameLowerCase}}MicroServer{
        service: New{{.ServiceName}}NativeServer(service, opts...),
    }
	return server
}

// NativeServer returns *{{.ServiceNameLowerCase}}NativeServer which registered
func (server *{{$.ServiceNameLowerCase}}MicroServer) NativeServer() *{{.ServiceNameLowerCase}}NativeServer {
	return server.service
}
{{range $funcIndex, $func := .Functions}}
func (server *{{$.ServiceNameLowerCase}}MicroServer) {{$func.FuncName}}(ctx context.Context, in *{{$func.RequestDefinition.TypeNameWithGoPkg}}, result *{{ $func.ResponseDefinition.TypeNameWithGoPkg}}) error {
{{- if $func.AggregateRequest}}
    {{if $func.AggregateResponse}}
        {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}result{{$resIndex}}, {{end}}
    {{- else}}nativeServerResult, {{end -}}
    err := server.service.{{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx, {{end}}
    {{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}{{if ne $fieldIndex 0}}, {{end}}
    {{- if $arg.IsStructInPtr}}&
    {{- else if $arg.NeedCastInLucas}}convServer{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}}(
    {{- end -}}
    in.{{ if or $arg.IsStruct $arg.IsStructInPtr}}{{$arg.TypeName}}{{else}}{{$arg.FieldNameGenFromProtobuf}}{{end}}
    {{- if $arg.NeedCastInLucas}}){{end}}{{end}})
{{- else }}
    {{if $func.AggregateResponse}}
        {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}result{{$resIndex}}, {{end}}
    {{- else}}nativeServerResult,{{" "}} 
    {{- end}}err := server.service.{{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx, {{end}}in)
{{- end }}
    if err != nil {
         return err
    }
{{- if $func.AggregateResponse}}
    *result = {{ $func.ResponseDefinition.TypeNameWithGoPkg}} {
{{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}
        {{$rArg.FieldNameGenFromProtobuf}}:{{" "}} 
        {{- if $rArg.NeedCastInLucas}}convServer{{$func.FuncName}}Output{{$rArg.FieldNameGenFromProtobuf}}(
        {{- end}}result{{$resIndex}}
        {{- if $rArg.NeedCastInLucas}}){{end}},
{{- end}}
    }
{{- else }}
    *result = *nativeServerResult
{{- end }}
    return nil
}
{{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
{{- if $arg.NeedCastInLucas}}
{{- if $arg.IsMap}}

func convServer{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}} (in  map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}}) map[{{$arg.KeyTypeNameWithGoPkg}}]{{$arg.TypeNameWithGoPkg}} {
    out := make(map[{{$arg.KeyTypeNameWithGoPkg}}]{{$arg.TypeNameWithGoPkg}})
    for k, v := range in {
        out[
        {{- if $arg.KeyNeedCast}}{{$arg.KeyTypeNameWithGoPkg}}({{end}}k
        {{- if $arg.KeyNeedCast}}){{end}}] = {{if $arg.NeedCast}}{{$arg.TypeNameWithGoPkg}}({{end}}v
        {{- if $arg.NeedCast}}){{end}}
    }
    return out
}
{{- else if $arg.IsRepeated}}

func convServer{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}} (in []{{$arg.TypeGenFromProtobuf}}) []{{$arg.TypeNameWithGoPkg}} {
    out := make([]{{$arg.TypeNameWithGoPkg}}, len(in))
    for i := 0; i < len(in); i++ {
        out[i] = {{$arg.TypeNameWithGoPkg}}(in[i])
    }
    return out
}{{- else}}

func convServer{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}} (in {{$arg.TypeGenFromProtobuf}}) {{$arg.TypeNameWithGoPkg}} {
    return {{$arg.TypeNameWithGoPkg}}(in)
}
{{- end}}
{{- end}}
{{- end}}
{{- range $fieldIndex, $arg := $func.AggregatedResponseDefinition.Args}}
{{- if $arg.NeedCastInLucas}}
{{- if $arg.IsMap}}

func convServer{{$func.FuncName}}Output{{$arg.FieldNameGenFromProtobuf}} (in map[{{$arg.KeyTypeNameWithGoPkg}}]{{$arg.TypeNameWithGoPkg}}) map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}} {
    out := make(map[{{$arg.KeyTypeGenFromProtobuf}}]{{$arg.TypeGenFromProtobuf}})
    for k, v := range in {
        out[
        {{- if $arg.KeyNeedCast}}{{$arg.KeyTypeGenFromProtobuf}}({{end}}k
        {{- if $arg.KeyNeedCast}}){{end}}] = {{if $arg.NeedCast}}{{$arg.TypeGenFromProtobuf}}({{end}}v
        {{- if $arg.NeedCast}}){{end}}
    }
    return out
}
{{- else if $arg.IsRepeated}}

func convServer{{$func.FuncName}}Output{{$arg.FieldNameGenFromProtobuf}} (in []{{$arg.TypeNameWithGoPkg}}) []{{$arg.TypeGenFromProtobuf}} {
    out := make([]{{$arg.TypeGenFromProtobuf}}, len(in))
    for i := 0; i < len(in); i++ {
        out[i] = {{$arg.TypeGenFromProtobuf}}(in[i])
    }
    return out
}{{- else}}

func convServer{{$func.FuncName}}Output{{$arg.FieldNameGenFromProtobuf}} (in {{$arg.TypeNameWithGoPkg}}) {{$arg.TypeGenFromProtobuf}} {
    return {{$arg.TypeGenFromProtobuf}}(in)
}
{{- end}}
{{- end}}
{{- end}}
{{end}}
type {{.ServiceNameLowerCase}}NativeServer struct {
     service {{.ServiceName}}Native
     opts    *Options
}

// New{{.ServiceName}}NativeServer return GRPC style server implement
func New{{.ServiceName}}NativeServer(service {{.ServiceName}}Native, opts... Option) *{{.ServiceNameLowerCase}}NativeServer {
    server := &{{.ServiceNameLowerCase}}NativeServer{
        service: service,
        opts:    newOptions(),
    }
    for _, o := range opts {
		o(server.opts)
	}
	return server
}
{{range $funcIndex, $func := .Functions}}
{{- if $func.AggregateRequest}}
func (server *{{$.ServiceNameLowerCase}}NativeServer) {{$func.FuncName}}(ctx context.Context,{{" "}}
    {{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
        {{- if ne $fieldIndex 0}}, {{end}}arg{{$fieldIndex}}{{" "}} 
        {{- if $arg.IsPtr}}*
        {{- else if $arg.IsRepeated}}[]{{if $arg.IsPtrInRepeated}}*{{end}}
        {{- else if $arg.IsMap}}map[{{$arg.KeyTypeNameWithGoPkg}}]
        {{- end}}{{$arg.TypeNameWithGoPkg}}
    {{- end}}) (
{{- template "response" $func}}error) {
{{- else}}
func (server *{{$.ServiceNameLowerCase}}NativeServer) {{$func.FuncName}}(ctx context.Context, in *{{$func.RequestDefinition.TypeNameWithGoPkg}}) (
{{- template "response" $func}}error) {
{{- end}}
{{- if $func.AggregateResponse}}
    result := new({{$func.ResponseDefinition.TypeNameWithGoPkg}})
{{- end }}
{{- if $func.AggregateRequest}}
    in := &{{$func.RequestDefinition.TypeNameWithGoPkg}} {
{{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}
        {{if or $arg.IsStruct $arg.IsStructInPtr}}{{$arg.TypeName}}{{else}}{{$arg.FieldNameGenFromProtobuf}}{{end}}:{{" "}}
        {{- if $arg.IsStructInPtr}}*
        {{- else if $arg.NeedCastInLucas}}convClient{{$func.FuncName}}Input{{$arg.FieldNameGenFromProtobuf}}(
        {{- end -}}
        arg{{$fieldIndex}}{{if $arg.NeedCastInLucas}}){{end}},
{{- end}}
    }
{{- end }} 
    if server.opts.inputPreHandler != nil {
		err := server.opts.inputPreHandler(ctx, in)
		if err != nil {
{{- if $func.AggregateResponse}}
{{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}
            var ret{{$resIndex}} {{$rArg.TypeNameWithGoPkg}}
{{- end}}
{{- end}}
			return{{" "}}
            {{- if $func.AggregateResponse}}
                {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}ret{{$resIndex}},{{" "}}
                {{- end}}
            {{- else}}nil,{{" "}} 
            {{- end}}err
		}
	}
{{- if $func.AggregateRequest}}
    {{if $func.AggregateResponse}}
        {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}result{{$resIndex}},{{" "}}
        {{- end}}
    {{- else}}result,{{" "}}
    {{- end}}err := server.service.{{$func.FuncName}}(
        {{- if $func.WithCtx}}ctx, {{end}}
        {{- range $fieldIndex, $arg := $func.AggregatedRequestDefinition.Args}}{{if ne $fieldIndex 0}}, {{end}}
        arg{{$fieldIndex}}
    {{- end}})
{{- else }}
    {{if $func.AggregateResponse}}
        {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}result{{$resIndex}}, {{end}}
    {{- else}}result,{{" "}}
    {{- end}}err := server.service.{{$func.FuncName}}(
    {{- if $func.WithCtx}}ctx,{{" "}} 
    {{- end}}in)
{{- end}}
{{- if $func.AggregateResponse}}
{{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}
    result.{{$rArg.FieldNameGenFromProtobuf}} ={{" "}}
    {{- if $rArg.NeedCastInLucas}}convServer{{$func.FuncName}}Output{{$rArg.FieldNameGenFromProtobuf}}(
    {{- end}}result{{$resIndex}}{{- if $rArg.NeedCastInLucas}}){{end}}
{{- end}}
{{- end}}
    if server.opts.outputHandler != nil {
	    err = server.opts.outputHandler(ctx, result, err)
    }
    return{{" "}} 
    {{- if $func.AggregateResponse}}
        {{- range $resIndex, $rArg := $func.AggregatedResponseDefinition.Args}}result{{$resIndex}}, {{end}}
    {{- else}}result,{{" "}} 
    {{- end}}err
}
{{end}}

type Options struct {
	inputPreHandler InputPreHandleFunc
	outputHandler   OutputHandleFunc
}

type Option func(*Options)

func newOptions() *Options {
	return &Options{}
}

type InputPreHandleFunc func(ctx context.Context, in interface{}) error
type OutputHandleFunc func(ctx context.Context, out interface{}, err error) error

// WithInputPreHandle register input preprocess function which call before invoking handler.
func WithInputPreHandle(inputPreHandleFunc InputPreHandleFunc) Option {
	return func(o *Options) {
		o.inputPreHandler = inputPreHandleFunc
	}
}

// WithOutputHandle register output processing function which call after invoking handler.
func WithOutputHandle(outputHandlerFunc OutputHandleFunc) Option {
	return func(o *Options) {
		o.outputHandler = outputHandlerFunc
	}
}
`

// ResponseTemplate is sub template for response
var ResponseTemplate = `{{- if .AggregateResponse}}
{{- range $resIndex, $rArg := .AggregatedResponseDefinition.Args}}
    {{- if $rArg.IsPtr}}*{{$rArg.TypeNameWithGoPkg}}
    {{- else if $rArg.IsRepeated}}[]{{$rArg.TypeNameWithGoPkg}}
    {{- else if $rArg.IsMap}}map[{{$rArg.KeyTypeNameWithGoPkg}}]{{$rArg.KeyTypeNameWithGoPkg}}
    {{- else}}{{$rArg.TypeNameWithGoPkg}}
    {{- end}},{{" "}} 
{{- end}}
{{- else}}*{{.ResponseDefinition.TypeNameWithGoPkg}}, {{end}}`
